RHadoop培训 之 R基础课
===========

[RHadoop实践系列文章](http://blog.fens.me/series-rhadoop/)，包含了R语言与Hadoop结合进行海量数据分析。Hadoop主要用来存储海量数据，R语言完成MapReduce 算法，用来替代Java的MapReduce实现。有了RHadoop可以让广大的R语言爱好者，有更强大的工具处理大数据1G, 10G, 100G, TB, PB。 由于大数据所带来的单机性能问题，可能会一去不复返了。

RHadoop实践是一套系列文章，主要包括[”Hadoop环境搭建”](http://blog.fens.me/rhadoop-hadoop/)，[”RHadoop安装与使用”](http://blog.fens.me/rhadoop-rhadoop/)，[”R实现MapReduce的协同过滤算法”](http://blog.fens.me/rhadoop-mapreduce-rmr/)，[”HBase和rhbase的安装与使用”](http://blog.fens.me/rhadoop-hbase-rhase/)。对于单独的R语言爱好者，Java爱好者，或者Hadoop爱好者来说，同时具备三种语言知识并不容 易。此文虽为入门文章，但R,Java,Hadoop基础知识还是需要大家提前掌握。

####关于作者

+ 张丹(Conan), 程序员Java,R,PHP,Javascript
+ weibo：@Conan_Z
+ blog: http://blog.fens.me
+ email: bsspirit@gmail.com

####转载请注明出处：  
http://blog.fens.me/rhadoop-linux-basic/

![](http://blog.fens.me/wp-content/uploads/2013/07/r-title.png)

####前言
覆盖R基础知识，快速上手，RHadoop环境的搭建基础课。

####目录

1. 背景知识
2. 开发环境
3. R语法
4. R基本函数
5. R的扩展包

##1. 背景知识

###R起源
R 是一个有着统计分析功能及强大作图功能的软件系统，是由奥克兰大学统计学系的Ross Ihaka和Robert Gentleman 共同创立。由于R 受Becker, Chambers & Wilks 创立的S 和Sussman 的Scheme两种语言的影响，所以R 看起来和S 语言非常相似。

R 是一个世界范围统计工作者共同协作的产物，至2013 年2 月共计近5000 个包可在互联网上自由下载，这些都是各行业数据分析同行的工作结晶。

###R的特点

1. 有效的数据处理和保存机制。
2. 拥有一整套数组和矩阵的操作运算符。
3. 一系列连贯而又完整的数据分析中间工具。
4. 图形统计可以对数据直接进行分析和显示，可用于多种图形设备。
5. 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数以及输入输出接口。
6. R语言是彻底面向对象的统计编程语言。
7. R语言和其它编程语言、数据库之间有很好的接口。
8. R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。
9. R语言具有丰富的网上资源

###R的下载和安装
R是一个免费的自由软件，它有UNIX、LINUX、MacOS和WINDOWS版本，都是可以免费下载和使用的,在那儿可以下载到R的安装程序、各种外挂程序和文档。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。

R的官方网站： http://www.r-project.org/

###Linux Ubuntu的R安装

```{bash}

~ sudo vi /etc/apt/sources.list
deb http://mirror.bjtu.edu.cn/cran/bin/linux/ubuntu precise/

~ sudo apt-get update
~ sudo apt-get install r-base-core=2.15.3-1precise0precise1
```

##2. 开发环境

R命令行环境：

![](http://blog.fens.me/wp-content/uploads/2013/07/r-cmd.png)

R默认的界面环境：

![](http://blog.fens.me/wp-content/uploads/2013/07/r-gui.png)

RStudio的IDE开发环境： http://www.rstudio.com/

![](http://blog.fens.me/wp-content/uploads/2013/07/r-studio.png)

##3. R语法

R是一种语法非常简单的表达式语言(expression language),大小写敏感。
可以在R 环境下使用的命名字符集依赖于R 所运行的系统和国家(系统的locale 设置),允许数字,字母,“.”,“_”

###1). 命名
命名必须以”.”或者字母开头，以”.”开头时第二个字符不允许是数字。

###2). 基本命令
基本命令要么是表达式（expressions），要么就是赋值（assignments）。

+ 表达式，命令将被解析，并将结果显示在屏幕上，同时清空该命令所占内存。
+ 赋值，命令将被解,并把值传给变量,但结果不会自动显示在屏幕上。

命令可以被”;”隔开或者另起一行。基本命令可以通过大括弧{},放在一起构成一个复合表达式。

+ 注释：一行中以井号”#”开头
+ 换行：如果一条命令在一行结束的时候在语法上还不完整，换行提示符，默认是+

###3). 基本的对象
R创建和控制的实体被称为对象。它们可以是变量，数组，字符串，函数，或者其他通过这些实体定义的一般性的结构。

+ 矩阵（matrix）或者更为一般的数组（array）是多维的广义向量。实际上，它们就是向量，而且可以同时被两个或者更多个索引引用，并且以特有的方式显示出来。
+ 因子（factor）为处理分类数据提供的一种有效方法。
+ 列表（list）是一种泛化（general form）的向量。它没有要求所有元素是同一类型，许多时候它本身就是向量和列表类型。列表为统计计算的结果返回提供了一种便利的方法。
+ 数据框（data frame）是和矩阵类似的一种结构。在数据框中，列可以是不同的对象。可以把数据框看作是一个行表示观测个体并且（可能）同时拥有数值变量和分类变量的`数据矩阵’ 。许多实验数据都可以很好的用数据框描述：处理方式是分类变量而响应值是数值变量。
+ 函数（function）是可以保存在项目工作空间的R 对象。该对象为R 提供了一个简单而又便利的功能扩充方法。见编写你自己的函数

在R会话过程中，对象是通过名字创建和保存的。objects(), ls()可以显示当前会话的对象名字。rm()可以删除对象。

####对象持久化
R 会话中创建的所有对象可以永久地保存在一个文件中以便于以后的R 会话调用。在每一次R 会话结束的时候，你可以保存当前所有可用的对象。如果你想这样做，这些对象将会写入当前目录下一个叫.RData的文件中，并且所有在这次会话中用过的命令行都会被保存在.Rhistory 的文件中。当R 再次在同一目录下启动，这些对象将从这个文件中重新导入工作空间。同时，相关的历史命令文件也会被导入。

###4). 向量和赋值
向量是由一串有序数值构成的序列

```{bash}
x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
```

函数c()完成的赋值语句。这里的函数c() 可以有任意多个参数，而它返回的值则是一个把这些参数首尾相连形成的向量。

赋值也可以用函数assign()实现。

```{bash}
assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
```

赋值符<-,->可以看作是该命令一个语义上的缩写。

```{bash}
c(10.4, 5.6, 3.1, 6.4, 21.7) -> x
```

向量运算
+ 在算术表达式中使用向量将会对该向量的每一个元素都进行同样算术运算。
+ 出现在同一个表达式中的向量最好是长度一致。如果他们的长度不一样，该表达式的值将是一个和其中最长向量等长的向量。
+ 表达式中短的向量会被循环使用以达到最长向量的长度。
+ 对于一个常数就是简单的重复。

```{bash}
v <- 2*x + y + 1
```

####逻辑向量
逻辑向量元素可以被赋予的值,有TRUE，FALSE 和NA 逻辑向量可以由条件式（conditions）产生 temp <- x > 13

####字符向量
字符向量就是字符串，可以用双引号和单引号作分割符。

paste():可以把单独的字符连成字符串，可以有任意多的参数。参数中的任何数字都将被显式地强制转换成字符串，而且以同样的方式在终端显示。默认的分隔符是单个的空格符。

修改分隔符换成”“

```{bash}
labs <- paste(c("X","Y"), 1:10, sep="")
```

####索引向量：通过索引值可以选择和修改一个数据集的子集
一个向量的子集元素可以通过向量名后面的方括号中加入索引向量得到。如果一个表达式的结果是向量，则我们可以直接在表达式的末尾方括号中加入索引向量以得到结果向量的子向量.

+ 逻辑向量:索引向量必须和被挑选元素的向量长度一致。向量中对应索引向量元素为TRUE 的元素将会被选中，而那些对应FALSE 的元素则被忽略。

```{bash}
y <- x[!is.na(x)]
```

+ 正整数向量:索引向量必须是1, 2, … , length(x)的子向量。索引向量中索引对应的元素将会被选中，并且在结果向量中的次序和索引向量中的次序一致。这种索引向量可以是任意长度的，结果向量的长度和索引向量完全一致。

```{bash}
x[1:10]
```

+ 负整数向量:这种索引向量指定被排除的元素而不是包括进来。

```{bash}
y <- x[-(1:5)]
```

+ 字符串向量:这可能仅仅用于一个对象可以用names 属性来识别它的元素。名字向量的子向量可以像上面第二条提到的正整数标签一样使用。

```{bash}
fruit <- c(5, 10, 1, 20) 
names(fruit) <- c("orange”, “banana”, “apple”, “peach”) 
lunch <- fruit[c(“apple”,“orange”)]
```

###5).运算符
算术运算符：

```{bash}
 + - * / 
```

逻辑运算符：

```{bash}
  <，<=，>，>=，==,!=, &, |, ! 
```

数学函数：

```{bash}
log，exp，sin，cos，tan，sqrt ，max ，min，range，length，sum，prod，var

注：var(x): 等价于sum((x-mean(x))^2)/(length(x)-1)
```

###6). 控制语句
####条件语句:if

```{bash}
if (expr1 ) expr2 else expr3
```

####循环控制：for,repeat,while

```{bash}
for (name in expr1 ) expr2
```

其中name 是循环变量，expr1是一个向量表达式，而expr2常常是根据虚拟变量name 而设计的成组表达式。在name 访问expr1所有可以取到的值时，expr2都会运行。

**警告：相比其他程序语言，R代码里面很少使用for(),执行效率很低**

```{bash}
repeat expr
while (condition) expr
```

+ 关键字break：可以用于结束任何循环，甚至是非常规的。它是结束repeat 循环的唯一办法。
+ 关键字next：可以用来结束一次特定的循环，然后直接跳入"下一次"循环。

###7). 生成正则序列
1:30 语句：等价于向量c(1, 2, …, 29, 30) 30:1 语句：可用来产生一个逆向的数列。  
seq：数列生成中最为常用的工具。seq(1,30,1) rep：把一个数的完整拷贝多次，保持数列顺序req(x,times=5)

###8). 缺损值
在某些情况下，向量的元素可能有残缺. 当一个元素或者值在统计的时候"不可得到"（not available）或者"值丢失" （missing value），相关位置可能会被保留并且赋予一个特定的值NA。 任何含有NA 数据的运算结果都将是NA。 函数is.na(x)返回一个和x同等长度的向量。它的某个元素值为TRUE 当且仅当x中对应元素是NA。

```{bash}
z <- c(1:3,NA); ind <- is.na(z)
```

第二种"缺损"值，也称为非数值NaN(Not a Number)

```{bash}
0/0 或 Inf
```

###9). 对象
####内在属性：模式和长度
R操作的实体是对象。实数或复数向量，逻辑向量和字符串向量之类的对象属于"原子"型的对象，因为它们的元素都是一样的类型或模式。R的对象类型包括数值型，复数型，逻辑型,字符型,和原生型。向量必须保证它的所有元素是一样的模式。因此任何给定的向量必须明确属于逻辑性，数值型，复数型，字符型或者原生型.

列表是任何模式的对象的有序序列。列表被认为是一种"递归"结构而不是原子结构,因为它们的元素可以以它们各自的方式单独列出。函数和表达式也是递归结构。

所有对象都有模式(mode)和长度(length)两个内在属性

```{bash}
mode(x),length(x)
```

####外部属性
+ attributes(x):给出对象当前定义的非内在属性的列表。
+ attr(object, name): 可以用来设置的外部属性。

```{bash}
z<-c(1:3,NA) 
attr(z, "name") <- "abc" 
attributes(z)
```

####对象的类属性
+ R里面的所有对象都属于类(class)，可以通过函数class(x)查看。
+ 对于简单的向量，类是对应的模式(mode)："numeric"，"logical"，"character" 或者"list"
+ 其他的类型，像"matrix"，"array"，"factor" 和"data.frame" 就可能是其他值。

###10). 因子(factor)
假定我们有一份来自澳大利亚所有州和行政区的信息样本 以及他们各自所在地的州名。

```{bash}
state <- c("tas", "sa", "qld", "nsw", "nsw", "nt")
```

在字符向量中，"有序"意味着以字母排序的。

创建因子factor：

```{bash}
statef <- factor(state)
statef
[1] tas sa  qld nsw nsw nt 
Levels: nsw nt qld sa tas
```

levels():可以用来得到因子的水平（levels）。

```{bash}
levels(statef)
[1] "nsw" "nt"  "qld" "sa"  "tas"
```

####函数tapply()和不规则数组
为计算样本中每个州的平均收入，我们可以用函数tapply()：

```{bash}
incomes <- c(60, 49, 40, 61, 64, 60)
incmeans <- tapply(incomes, statef, mean)
> incmeans
nsw   nt  qld   sa  tas 
62.5 60.0 40.0 49.0 60.0
```

函数tapply() 可以用来处理一个由多个分类因子决定的向量下标组合。例如，我们可能期望通过州名和性别把这税务会计师分类。

####有序因子
因子的水平是以字母顺序排列的，或者显式地在factor中指定。有时候因子的水平有自己的自然顺序并且这种顺序是有意义的。ordered()就是用来创建这种有序因子, ordered()和factor 基本完全一样。

大多数情况下，有序和无序因子的唯一差别在于前者显示的时候反应了各水平的顺序。在线性模型拟合的时候，两种因子对应的对照矩阵的意义是完全不同的。

###11). 数组
数组可以看作是带有多个下标类型相同的元素集合。  
维度向量(dimension vector)是一个正整数向量。如果它的长度为k，那么该数组就是k-维的。

向量只有在定义了dim属性后才能作为数组在R中使用。  
假定，z是一个含1500个元素的向量

```{bash}
    z<-seq(1,1500)
    dim(z) <- c(3,5,100)
    attributes(z)
    $dim
    [1]   3   5 100
```

对dim 属性的赋值使得该向量成一个3 ×5 ×100 的数组

####数组索引
数组元素可以通过给定数组名及其后方括号中用逗号隔开的下标访问。可以根据索引数组去给数组中不规则的元素集合赋值或者将数组中特定的元素返回到一个向量中

####array()
除了用设定一个向量dim 属性的方法来构建数组，它还可直接通过函数array将向量转换得到.

假定向量h 有24个或更少的数值，那么命令

```{bash}
h<-seq(1,24)
Z <- array(h, dim=c(3,4,2))
#等价操作
dim(Z) <- c(3,4,2)
```

####向量和数组混合运算

+ 表达式运算是从左到右进行的
+ 短的向量操作数将会被循环使用以达到其他操作数的长度
+ 有且只有短的向量和数组在一起，数组必须有一样的属性dim，否则返回一个错误
+ 向量操作数比矩阵或者数组操作数长时会引起错误
+ 如果数组结构给定，同时也没有关于向量的错误信息和强制转换操作，结果将是一个和它的数组操作数属性dim 一致的数组。

####数组的外积
数组一个非常重要的运算就是外积运算（outer product）。如果a 和b 是两个数值数组，它们的外积将是这样的一个数组：维度向量通过连接两个操作数的维度向量得到；数据向量则由a的数据向量元素和b的数据向量元素的所有可能乘积得到。外积是通过特别的操作符%o%实现：

```{bash}
ab <- a %o% b
ab <- outer(a, b, "*")
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    2    4    6
[3,]    3    6    9
```

命令中的乘法操作符可以被任意一个双变量函数代替。

```{bash}
x<-c(1,2,3);y<-c(2,3,4)
f <- function(x, y) cos(y)/(1 + x^2)
z <- outer(x, y, f)
两个常规向量的外积是一个双下标的数组(就是矩阵，最大秩为1)。
```

####数组的广义转置
函数aperm(a, perm) 可以用来重排一个数组a

```{bash}
B <- aperm(z, c(2,1))
#等价操作
t(z)
```

###12). 矩阵

矩阵是一个双下标的数组. R包括许多只对矩阵操作的操作符和函数。例如上面提到的t(X)就是矩阵的转置函数。函数nrow(A) 和ncol(A) 将会分别返回矩阵A 的行数和列数。

####矩阵相乘
操作符%*% 用于矩阵相乘。  
如果A和B是大小一样的方阵，那么

```{bash}
A * B
```

将是一个对应元素乘积的矩阵，而

```{bash}
A %*% B
```

则是一个矩阵积。如果x 是一个向量，那么

```{bash}
x %*% A %*% x
```

crossprod():可以完成"矢积"运算，也就是说crossprod(X,y) 和t(X) %*% y 等价，而且在运算上更为高效。  
diag():返回以该向量元素为对角元素的对角矩阵。

####性方程和求逆
求解线性方程组是矩阵乘法的逆运算。当下面的命令运行后，

```{bash}
b <- A %*% x
```

如果仅仅给出A 和b，那么x 就是该线性方程组的根。在R 里面，用命令

```{bash}
solve(A,b)
```

矩阵的逆可以用下面的命令计算，

```{bash}
solve(A)
```

####特征值和特征向量
ev<-eigen(Sm):用来计算矩阵Sm 的特征值和特征向量。这个函数的返回值是一个 含有values 和vectors 两个分量的列表。

```{bash}
ev <- eigen(Sm)
```

ev$values表示Sm 的特征值向量，ev$vec 则是相应特征向量构成的一个矩阵。

####奇异值分解和行列式
svd(M): 可以把任意一个矩阵M作为一个参数, 且对M 进行奇异值分解。这包括一个和M 列空间一致的正交列U 的矩阵，一个和M 行空间一致的正交列V 的矩阵，以及一个正元素D 的对角矩阵，如M = U %*% D %*% t(V)。D 实际上以对角元素向量的形式返回。svd(M) 的结果是由d, u 和v构成的一个列表。

如果M 是一个方阵，就不难看出

```{bash}
absdetM <- prod(svd(M)$d)
```

计算M 行列式的绝对值。如果在各种矩阵中都需要这种运算，我们可以把它定义为一个R 函数

```{bash}
absdet <- function(M) prod(svd(M)$d)
```

此后, 我们可以把absdet() 当一个R 函数使用了。R有一个计算行列式的内置函数det和另外一个给出符号和模的函数。

```{bash}
evals <- eigen(Sm, only.values = TRUE)$values
```












































